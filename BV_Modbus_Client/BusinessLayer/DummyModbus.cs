//using NModbus;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace BV_Modbus_Client.BusinessLayer
{
    internal class DummyModbus //: IModbusMaster

    {
        //public IModbusTransport Transport => throw new NotImplementedException();

        //public void Dispose()
        //{
        //}

        //public TResponse ExecuteCustomMessage<TResponse>(IModbusMessage request) where TResponse : IModbusMessage, new()
        //{
        //    throw new NotImplementedException();
        //}

        //public bool[] ReadCoils(byte slaveAddress, ushort startAddress, ushort numberOfPoints)
        //{
        //    return new bool[numberOfPoints];
        //}

        //public Task<bool[]> ReadCoilsAsync(byte slaveAddress, ushort startAddress, ushort numberOfPoints)
        //{
        //    throw new NotImplementedException();
        //}

        //public ushort[] ReadHoldingRegisters(byte slaveAddress, ushort startAddress, ushort numberOfPoints)
        //{
        //    int[] t = Enumerable.Repeat(16968, ((ushort)numberOfPoints)).ToArray();
        //    return Array.ConvertAll(t, item => (ushort)item);
        //    //return new ushort[numberOfPoints];
        //}

        //public Task<ushort[]> ReadHoldingRegistersAsync(byte slaveAddress, ushort startAddress, ushort numberOfPoints)
        //{
        //    throw new NotImplementedException();
        //}

        //public ushort[] ReadInputRegisters(byte slaveAddress, ushort startAddress, ushort numberOfPoints)
        //{
        //    return new ushort[numberOfPoints];
        //}

        //public Task<ushort[]> ReadInputRegistersAsync(byte slaveAddress, ushort startAddress, ushort numberOfPoints)
        //{
        //    throw new NotImplementedException();
        //}

        //public bool[] ReadInputs(byte slaveAddress, ushort startAddress, ushort numberOfPoints)
        //{
        //    return new bool[numberOfPoints];
        //}

        //public Task<bool[]> ReadInputsAsync(byte slaveAddress, ushort startAddress, ushort numberOfPoints)
        //{
        //    throw new NotImplementedException();
        //}

        //public ushort[] ReadWriteMultipleRegisters(byte slaveAddress, ushort startReadAddress, ushort numberOfPointsToRead, ushort startWriteAddress, ushort[] writeData)
        //{
        //    throw new NotImplementedException();
        //}

        //public Task<ushort[]> ReadWriteMultipleRegistersAsync(byte slaveAddress, ushort startReadAddress, ushort numberOfPointsToRead, ushort startWriteAddress, ushort[] writeData)
        //{
        //    throw new NotImplementedException();
        //}

        //public void WriteFileRecord(byte slaveAdress, ushort fileNumber, ushort startingAddress, byte[] data)
        //{
        //}

        //public void WriteMultipleCoils(byte slaveAddress, ushort startAddress, bool[] data)
        //{
        //}

        //public Task WriteMultipleCoilsAsync(byte slaveAddress, ushort startAddress, bool[] data)
        //{
        //    throw new NotImplementedException();
        //}

        //public void WriteMultipleRegisters(byte slaveAddress, ushort startAddress, ushort[] data)
        //{
        //}

        //public Task WriteMultipleRegistersAsync(byte slaveAddress, ushort startAddress, ushort[] data)
        //{
        //    throw new NotImplementedException();
        //}

        //public void WriteSingleCoil(byte slaveAddress, ushort coilAddress, bool value)
        //{
        //}

        //public Task WriteSingleCoilAsync(byte slaveAddress, ushort coilAddress, bool value)
        //{
        //    throw new NotImplementedException();
        //}

        //public void WriteSingleRegister(byte slaveAddress, ushort registerAddress, ushort value)
        //{
        //}

        //public Task WriteSingleRegisterAsync(byte slaveAddress, ushort registerAddress, ushort value)
        //{
        //    throw new NotImplementedException();
        //}
    }
}
